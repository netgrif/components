import {Injectable, Optional, Type} from '@angular/core';
import {LoggerService} from '../../logger/services/logger.service';
import {OperatorService} from '../operator-service/operator.service';
import {Category} from '../models/category/category';
import {OptionalDependencies} from './optional-dependencies';
import {UserResourceService} from '../../resources/engine-endpoint/user-resource.service';
import {SearchIndexResolverService} from '../search-keyword-resolver-service/search-index-resolver.service';
import {CategoryGeneratorMetadata} from '../models/persistance/generator-metadata';
import {CategoryResolverService} from './category-resolver.service';
import {AllowedNetsService} from '../../allowed-nets/services/allowed-nets.service';
import {Observable, ReplaySubject} from 'rxjs';

/**
 * Can be used to generate {@link Category} class instances.
 *
 * Can only generate instances of Categories that take {@link OperatorService} as their first argument, {@link LoggerService} as their
 * second argument and {@link OptionalDependencies} object is passed as the third. `null` is passed as the third argument otherwise.
 * You can extend this class to support your Categories, but make sure that an injection token for this classes name
 * is still provided for the library components that use it.
 */
@Injectable()
export class CategoryFactory {

    protected _optionalDependencies: OptionalDependencies;

    constructor(protected _operators: OperatorService,
                protected _log: LoggerService,
                protected _searchIndexResolverService: SearchIndexResolverService,
                protected _categoryResolver: CategoryResolverService,
                protected _allowedNetsService: AllowedNetsService,
                @Optional() protected _userResourceService: UserResourceService) {
        this._optionalDependencies = {
            categoryFactory: this,
            searchIndexResolver: this._searchIndexResolverService,
            allowedNetsService: this._allowedNetsService,
            userResourceService: this._userResourceService,
        };
    }

    /**
     * Create an instance of {@link Category} class.
     * @param categoryClass the class that should be instantiated
     * @returns a new instance of the provided class
     */
    public get(categoryClass: Type<Category<any>>): Category<any> {
        return new categoryClass(this._operators, this._log, this._optionalDependencies);
    }

    /**
     * Create an instance of {@link Category} class and preselects it's default operator.
     * @param categoryClass the class that should be instantiated
     * @returns a new instance of the provided class with the default operator selected
     */
    public getWithDefaultOperator(categoryClass: Type<Category<any>>): Category<any> {
        const category = this.get(categoryClass);
        category.selectDefaultOperator();
        return category;
    }

    /**
     * Attempts to deserialize the provided `string` into a {@link Category} class,
     * create an instance from it and preselect it's default operator.
     * @param serializedCategoryClass the serialized form of a {@Link Category} class
     * @returns a new instance of the provided class with the default operator selected
     */
    public getByNameWithDefaultOperator(serializedCategoryClass: string): Category<any> {
        const categoryClass = this._categoryResolver.toClass(serializedCategoryClass);
        if (categoryClass === undefined) {
            this._log.errorAndThrow(new Error(`Category '${serializedCategoryClass}' could not be deserialized! Cannot create instance!`));
        }
        return this.getWithDefaultOperator(categoryClass);
    }

    /**
     * Reconstructs a {@link Category} from saved metadata. The category is NOT in its initial state.
     * It is in its final state instead and immediately provides a search predicate.
     * @param metadata - the saved metadata generated by a previous {@link Category} instance
     * @returns an Observable, that emits the deserialized Category, once the deserialization finishes
     */
    public getFromMetadata(metadata: CategoryGeneratorMetadata): Observable<Category<any>> {
        const result$ = new ReplaySubject<Category<any>>(1);
        const categoryClass = this._categoryResolver.toClass(metadata.category);
        if (categoryClass === undefined) {
            this._log.errorAndThrow(new Error(`Category '${metadata.category}' could not be deserialized! Cannot create instance!`));
        }
        const category = this.get(categoryClass);
        category.loadFromMetadata(metadata).subscribe(() => {
            result$.next(category);
            result$.complete();
        });
        return result$.asObservable();
    }
}
