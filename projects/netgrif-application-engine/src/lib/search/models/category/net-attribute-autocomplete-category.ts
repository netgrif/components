import {NoConfigurationAutocompleteCategory} from './no-configuration-autocomplete-category';
import {NetAttributePair} from './net-attribute-pair';
import {Operator} from '../operator/operator';
import {LoggerService} from '../../../logger/services/logger.service';
import {Net} from '../../../process/net';
import {NameIdPair} from './name-id-pair';
import {Query} from '../query/query';
import {BooleanOperator} from '../boolean-operator';
import {Category} from './category';
import {Subscription} from 'rxjs';
import {OperatorService} from '../../operator-service/operator.service';
import {OptionalDependencies} from '../../category-factory/optional-dependencies';

/**
 * A utility class for autocomplete search categories that are net specific, such as searching by roles, or tasks.
 *
 * The generated queries combine the ids of the selected attribute with the net id, so that no unexpected results are found.
 */
export abstract class NetAttributeAutocompleteCategory extends NoConfigurationAutocompleteCategory<NetAttributePair> {

    private _allowedNetsSub: Subscription;
    private _destroyed: boolean;

    protected constructor(elasticKeywords: Array<string>,
                          allowedOperators: Array<Operator<any>>,
                          translationPath: string,
                          log: LoggerService,
                          operatorService: OperatorService,
                          protected _optionalDependencies: OptionalDependencies) {
        super(elasticKeywords, allowedOperators, translationPath, log, operatorService);
    }

    destroy() {
        super.destroy();
        if (this._allowedNetsSub && !this._allowedNetsSub.closed) {
            this._allowedNetsSub.unsubscribe();
        }
        this._destroyed = true;
    }

    protected createOptions(): void {
        if (this._destroyed) {
            return;
        }

        this._allowedNetsSub = this._optionalDependencies.allowedNetsService.allowedNets$.subscribe(allowedNets => {
            this._optionsMap.clear();
            allowedNets.forEach(petriNet => {
                this.extractAttributes(petriNet)
                    .filter(pair => pair.name && pair.name.trim().length > 0)
                    .forEach(pair => {
                        this.addToMap(pair.name, {
                            netId: this.getPetriNetIdentifier(petriNet),
                            attributeId: pair.id
                        });
                    });
            });
            this.updateOptions();
        });
    }

    /**
     * This method should extract the relevant attribute display names and ids.
     * They will be automatically paired with the net id for further use by this search category.
     *
     * @param petriNet Petri net that should have its search relevant attributes extracted
     * @returns an array of the attribute display name and id pairs
     */
    protected abstract extractAttributes(petriNet: Net): Array<NameIdPair>;

    /**
     *  This method should return the appropriate category instance for searching of processes, so that process queries
     *  can be generated with it.
     *
     *  Currently it can be either the {@link CaseProcess} or the {@link TaskProcess} category class.
     */
    protected abstract getProcessCategory(): Category<Array<string>>;

    /**
     * This method should return the appropriate identifier of a PetriNet.
     *
     * Categories that query cases should use process identifier.
     *
     * Categories that query tasks should use stringId.
     *
     * @param net PetriNet whose identifier should be extracted
     */
    protected abstract getPetriNetIdentifier(net: Net): string;

    /**
     * Generates the query as a combination of the selected attribute pairs.
     * Each attribute is ANDed with its net id and ORed with other attributes.
     * @param userInput inputs selected by the user in each of the operand input fields
     * @returns the Query generated by the selected Operator
     */
    protected generateQuery(userInput: Array<Array<NetAttributePair>>): Query {
        if (userInput.length !== 1) {
            throw new Error('NetAttributeAutocompleteCategories currently doesn\'t support operators with arity other than 1!');
        }

        const matchingPairs = userInput[0];

        const queries = matchingPairs.map(pair => {
            const taskQuery = this.selectedOperator.createQuery(this.elasticKeywords, [pair.attributeId]);
            const netQuery = this.getProcessCategory().generatePredicate([[pair.netId]]).query;
            return Query.combineQueries([taskQuery, netQuery], BooleanOperator.AND);
        });
        return Query.combineQueries(queries, BooleanOperator.OR);
    }
}
